import fs from 'fs/promises';
import path from 'path';
import { logger } from '../../utils/logger';
import { ParsedOffnightEvent, formatOffnightEvents, formatOffnightEvent } from './offnightPatternMatcher';
import { CacheManager } from '../cache/cacheManager';
import { updateGithubFile } from '../../index';

interface ManualEntry {
  content: string;
  date: Date;
  addedAt: number;
}

export class OffnightFileManager {
  constructor(
    private readonly filePath: string,
    private readonly cacheManager: CacheManager
  ) {}

  /**
   * Formats a single event for file output
   */
  formatEventForFile(event: ParsedOffnightEvent): string {
    return formatOffnightEvent(event);
  }

  /**
   * Parses date from a line in offnight.txt format
   */
  parseDateFromLine(line: string): Date | null {
    // Expected format: "Day M/D Time Timezone. Event Title."
    const match = line.match(/(\w+)\s+(\d{1,2})\/(\d{1,2})\s+/);
    if (match) {
      const month = parseInt(match[2]) - 1; // Month is 0-indexed
      const day = parseInt(match[3]);
      const year = new Date().getFullYear();
      // Create date and adjust year if needed
      let date = new Date(year, month, day);
      if (date < new Date()) {
        // If date is in the past, assume next year
        date = new Date(year + 1, month, day);
      }
      return date;
    }
    return null;
  }

  /**
   * Reads the current offnight.txt file and identifies manual entries
   * Manual entries are any lines not present in the new bot-generated events
   */
  async readManualEntriesExcludingBotEvents(botEvents: ParsedOffnightEvent[]): Promise<ManualEntry[]> {
    try {
      const content = await fs.readFile(this.filePath, 'utf-8');
      const lines = content.split('\n').map(line => line.trim()).filter(line => line);
      
      logger.info(`Reading ${lines.length} lines from offnight.txt`);
      
      // Create a set of current bot event base lines for comparison
      const currentBotEventBaseLines = new Set<string>();
      botEvents.forEach(event => {
        const baseLine = this.formatEventForFile(event);
        currentBotEventBaseLines.add(baseLine);
        logger.debug(`Current bot event base: "${baseLine}"`);
      });
      
      // Get cached bot events for comparison
      const cached = this.cacheManager.getOffnightSchedule();
      const oldBotEventBaseLines = new Set<string>();
      
      if (cached?.content) {
        cached.content.split('\n').map(line => line.trim()).filter(line => line).forEach(line => {
          oldBotEventBaseLines.add(line);
          logger.debug(`Cached bot event base: "${line}"`);
        });
      } else {
        logger.debug('No cached bot events found');
      }

      const manualEntries: ManualEntry[] = [];

      for (const line of lines) {
        const baseLine = line;
        
        // Check if this line matches current bot events
        const matchesCurrentBot = currentBotEventBaseLines.has(baseLine);
        
        // Check if this line looks like a bot event
        const looksLikeBot = this.looksLikeBotEvent(line);
        
        // Check if this line matches old bot events
        const matchesOldBot = oldBotEventBaseLines.has(baseLine);

        // Determine if this is a manual entry
        let isManual = false;
        
        if (cached?.content) {
          // If we have cache, use the original logic
          isManual = !matchesCurrentBot && !matchesOldBot;
        } else {
          // If no cache, only preserve if it doesn't match current bot events AND doesn't look like a bot event
          isManual = !matchesCurrentBot && !looksLikeBot;
        }

        if (isManual) {
          const date = this.parseDateFromLine(line) || new Date();
          manualEntries.push({
            content: line,
            date: date,
            addedAt: Date.now()
          });
          logger.debug(`Preserving manual entry: "${line}"`);
        } else {
          logger.debug(`Removing line: "${line}"`);
        }
      }

      logger.info(`Found ${manualEntries.length} true manual entries in offnight.txt`);
      return manualEntries;
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        logger.info('No offnight.txt file found');
        return [];
      }
      logger.error(`Error reading manual entries: ${error.message}`);
      throw error;
    }
  }

  /**
   * Determines if a line looks like it was generated by the bot
   * Bot events typically have specific formatting patterns
   */
  private looksLikeBotEvent(line: string): boolean {
    // Bot events MUST have "Hosted by" suffix - this is the primary indicator
    if (line.includes('Hosted by')) {
      return true;
    }
    
    // If no "Hosted by", it's likely a manual entry, even if it follows the date/time pattern
    // Manual entries can have the same date/time format but won't have "Hosted by"
    return false;
  }

  /**
   * Cleans up past bot-generated events from the offnight.txt file
   * This removes any bot entries that are in the past while preserving manual entries
   */
  async cleanupPastBotEvents(): Promise<{ removedCount: number; preservedCount: number }> {
    try {
      const content = await fs.readFile(this.filePath, 'utf-8');
      const lines = content.split('\n').map(line => line.trim()).filter(line => line);
      
      const currentDate = new Date();
      
      // Get the current cache to identify which events are bot-generated
      const cached = this.cacheManager.getOffnightSchedule();
      if (!cached) {
        logger.info('üìã No cache found, skipping cleanup to preserve all entries');
        return { removedCount: 0, preservedCount: lines.length };
      }
      
      // Create a set of bot-generated event lines from the cache
      const botEventLines = new Set<string>();
      if (cached.content) {
        const cachedLines = cached.content.split('\n').map(line => line.trim()).filter(line => line);
        cachedLines.forEach(line => botEventLines.add(line));
      }
      
      let removedCount = 0;
      let preservedCount = 0;
      const cleanedLines: string[] = [];
      
      for (const line of lines) {
        // Check if this line is in the cache as a bot-generated event
        if (botEventLines.has(line)) {
          const eventDate = this.parseDateFromLine(line);
          if (eventDate && eventDate < currentDate) {
            // This is a past bot event, remove it
            logger.info(`üóëÔ∏è Removing past bot event: ${line}`);
            removedCount++;
          } else {
            // This is a future bot event, keep it
            cleanedLines.push(line);
            preservedCount++;
          }
        } else {
          // This is NOT in the cache, so it's a manual entry - always preserve it
          logger.info(`üìù Preserving manual entry: ${line}`);
          cleanedLines.push(line);
          preservedCount++;
        }
      }
      
      if (removedCount > 0) {
        // Write the cleaned content back to the file
        const cleanedContent = cleanedLines.join('\n');
        await fs.writeFile(this.filePath, cleanedContent, 'utf-8');
        logger.info(`üßπ Cleaned up ${removedCount} past bot events, preserved ${preservedCount} entries`);
        // Sync to GitHub after cleanup
        const syncSuccess = await this.syncToGitHub();
        if (!syncSuccess) {
          logger.error('‚ùå GitHub sync failed after cleanup');
        }
      } else {
        logger.info(`üìã No past bot events found to clean up`);
      }
      
      return { removedCount, preservedCount };
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        logger.info('üìÑ No offnight.txt file found for cleanup');
        return { removedCount: 0, preservedCount: 0 };
      }
      logger.error(`‚ùå Error cleaning up past bot events: ${error.message}`);
      throw error;
    }
  }

  /**
   * Generates the file content string from events and manual entries
   */
  generateFileContent(events: ParsedOffnightEvent[], manualEntries: ManualEntry[]): string {
      // Combine bot events and manual entries
      const allEntries = [
        ...events.map(event => ({
          content: this.formatEventForFile(event),
          date: event.date,
          isManual: false
        })),
        ...manualEntries.map(entry => ({
          content: entry.content,
          date: entry.date,
          isManual: true
        }))
      ];
      
      // Sort by date
      allEntries.sort((a, b) => a.date.getTime() - b.date.getTime());
      
      // Create final content
    return allEntries.map(entry => entry.content).join('\n');
  }

  /**
   * Writes events to offnight.txt file, preserving manual entries
   */
  async writeOffnightFile(content: string): Promise<void> {
    try {
      // Ensure directory exists
      const dir = path.dirname(this.filePath);
      await fs.mkdir(dir, { recursive: true });

      await fs.writeFile(this.filePath, content, 'utf-8');
      
      logger.info(`üìÑ Successfully wrote updated content to offnight.txt`);

    } catch (error) {
      logger.error(`‚ùå Error writing offnight.txt: ${error instanceof Error ? error.message : error}`);
      throw error;
    }
  }

  /**
   * Checks if events have changed and need updating
   */
  hasEventsChanged(newEvents: ParsedOffnightEvent[]): boolean {
    const cached = this.cacheManager.getOffnightSchedule();
    if (!cached) {
      logger.info('üìã No cached offnight schedule found, will update');
      return true;
    }

    // Create thread ID mapping for comparison
    const newThreadIds: { [threadId: string]: { lastUpdated: number; dates: string[] } } = {};
    newEvents.forEach(event => {
      if (event.originalThreadId) {
        if (!newThreadIds[event.originalThreadId]) {
          newThreadIds[event.originalThreadId] = {
            lastUpdated: Date.now(),
            dates: []
          };
        }
        newThreadIds[event.originalThreadId].dates.push(event.date.toISOString());
      }
    });

    // Compare thread IDs and dates
    const cachedThreadIds = cached.threadIds;
    
    // Check if any new thread IDs exist
    for (const threadId of Object.keys(newThreadIds)) {
      if (!cachedThreadIds[threadId]) {
        logger.info(`üìã New thread found: ${threadId}`);
        return true;
      }
    }

    // Check if any cached thread IDs are missing (threads deleted)
    for (const threadId of Object.keys(cachedThreadIds)) {
      if (!newThreadIds[threadId]) {
        logger.info(`üìã Thread removed: ${threadId}`);
        return true;
      }
    }

    // Check if dates have changed for existing threads
    for (const threadId of Object.keys(newThreadIds)) {
      if (cachedThreadIds[threadId]) {
        const newDates = newThreadIds[threadId].dates.sort();
        const cachedDates = cachedThreadIds[threadId].dates.sort();
        
        if (JSON.stringify(newDates) !== JSON.stringify(cachedDates)) {
          logger.info(`üìã Dates changed for thread: ${threadId}`);
          return true;
        }
      }
    }

    logger.info('üìã No changes detected in offnight events');
    return false;
  }

  /**
   * Updates the cache with new events
   */
  updateCache(newEvents: ParsedOffnightEvent[], manualEntries: ManualEntry[]): void {
    // Create thread ID mapping
    const threadIds: { [threadId: string]: { lastUpdated: number; dates: string[] } } = {};
    newEvents.forEach(event => {
      if (event.originalThreadId) {
        if (!threadIds[event.originalThreadId]) {
          threadIds[event.originalThreadId] = {
            lastUpdated: Date.now(),
            dates: []
          };
        }
        threadIds[event.originalThreadId].dates.push(event.date.toISOString());
      }
    });

    // Extract manual entry content
    const manualEntryContent = manualEntries.map(entry => entry.content);

    // Update cache
    this.cacheManager.updateOffnightSchedule(
      formatOffnightEvents(newEvents),
      Date.now(),
      threadIds,
      manualEntryContent
    );

    logger.info(`üíæ Updated offnight cache with ${newEvents.length} events from ${Object.keys(threadIds).length} threads and ${manualEntries.length} manual entries`);
  }

  /**
   * Gets cached events if available
   */
  getCachedEvents(): ParsedOffnightEvent[] | null {
    const cached = this.cacheManager.getOffnightSchedule();
    if (!cached) {
      return null;
    }

    // For now, return null since we need to parse the content back to events
    // This could be enhanced to store parsed events in cache
    return null;
  }

  getCacheManager() {
    return this.cacheManager;
  }

  /**
   * Syncs the current offnight.txt file to GitHub with error recovery
   */
  async syncToGitHub(): Promise<boolean> {
    try {
      const githubPath = process.env.OFFNIGHT_FILE_PATH;
      if (!githubPath) {
        logger.error('OFFNIGHT_FILE_PATH is not set in environment variables');
        return false;
      }
      // Read the latest local file content
      const content = await fs.readFile(this.filePath, 'utf-8');
      logger.info(`üîó Syncing offnight.txt to GitHub at ${githubPath}...`);
      // Use the global updateGithubFile utility (assume imported)
      const success = await updateGithubFile(githubPath, content, false);
      if (success) {
        logger.info('‚úÖ Successfully synced offnight.txt to GitHub');
      } else {
        logger.error('‚ùå Failed to sync offnight.txt to GitHub');
      }
      return success;
    } catch (error) {
      logger.error(`‚ùå Error syncing offnight.txt to GitHub: ${error instanceof Error ? error.message : error}`);
      return false;
    }
  }

  /**
   * Reads the current offnight.txt file content
   */
  async readFile(): Promise<string> {
    try {
      const content = await fs.readFile(this.filePath, 'utf-8');
      return content;
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        logger.info('üìÑ No offnight.txt file found');
        return '';
      }
      logger.error(`‚ùå Error reading offnight.txt: ${error.message}`);
      throw error;
    }
  }
} 